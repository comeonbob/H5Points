- [TX](#tx)
  - [金融云-1](#金融云-1)
  - [微信广告-1](#微信广告-1)
  - [在线教育-1](#在线教育-1)
  - [医典-1](#医典-1)
  - [微信支付-1](#微信支付-1)
- [Alibaba](#alibaba)
  - [国际化事业部](#国际化事业部)
- [JD](#jd)
  - [taro](#taro)
## TX

### 金融云-1

### 微信广告-1

### 在线教育-1

### 医典-1

### 微信支付-1
1. 自我介绍；

   （工作经历、自己最近的职位、技术栈）

2. 介绍最熟悉的项目；

   （项目功能、架构、前端技术栈）

3. koa2中的中间件功能及原理；

   （功能：统一处理异常、日志打印等；原理：挂载阶段、执行阶段、源码）

4. http与https区别；

   （安全性、端口、CA证书）

5. http网络劫持原理；

   （在http请求中，运营商劫持了请求，提前返回有广告的页面；https可以防止被劫持，数据有签名，防止篡改）

6. 什么是闭包，闭包的应用；

   （在一个函数中，可以访问另外一个函数的变量，这样的函数称为闭包；作用：防止变量被回收；方便调用上下文局部变量，加强封装性；）

7. 前端内存泄漏有哪些； 

   （闭包、addEventListener、意外的全局变量，定时器，DOM引用）

8. 面向对象编程的特性；

   - 封装：对象把实现过程封装在方法中，调用者不需要知道细节；
   - 继承：对象A可以继承对象B的属性和方法，减少代码冗余；
   - 多态：对象可以表现多种形式，便于增量开发新功能（js中子类会重新父类的方法）；

9. ES5如何实现继承；

   ```javascript
   // 寄生组合继承（构造函数+原型对象）
   // 父类
   function Parent(name) {
     this.name = name
   }
   Parent.prototype.say = function () { console.log(this.name) }
   // 子类
   function Child(name, age) {
     // 属性继承
     Parent.call(this, name)
     this.age = age
   }
   // 方法继承
   Child.prototype = Object.create(Parent.prototype)
   Child.constructor = Child
   ```
   
10. 原型与原型链的理解；

    - 类有一个原型对象，prototype；
    - 实例对象有一个隐式原型对象，`__proto__`(Object.getPrototypeOf());
    - 实例的隐式原型对象指向类的原型对象；`a.__proto__ === A.prototype`;
    - 原型链继承：子类的原型对象上的隐式原型对象指向父类的原型对象；`Child.prototype.__proto__ === Parent.prototype`；（原型对象的继承）
    - 原型链一直往上找(隐式原型)，最后指向null, `Object.prototype.__proto__ === null`

11. webpack热更新原理；

    - 本地启动一个Node服务（用于文件服务）；
    - 当修改文件时，本地Node服务通过websocket向浏览器发送更新消息；
    - 浏览器收到消息后，通过http请求拉取最新的文件；（更新文件通过hash值，chunk名）

12. v8的内存回收机制；

    - 内存回收指的是堆内存回收；
    - 新生代内存（临时内存，一般大小32M）；
      - 分为From和To两块区域；
      - 遍历From中的对象，存活的对象不动，其它对象清除；
      - 交换From、To两块区域，同时重新排列内存（便于内存碎片整理）
    - 老生代内存（长时间占用、一般大小1.7G）
      - 标记清除（遍历堆中内存，有在用或者强引用的标记；最后清除没有标记的对象）；
      - 内存碎片整理；（重新整理存活对象，依次排列）
      - 考虑V8中JS是单线程，提出增量标记法，分为6次完成一次垃圾回收；（不阻塞业务代码）

13. web的安全机制

    - XSS：
      - 将重要的cookie设置为httpOnly；
      - 非框架代码渲染DOM时，需校验待渲染的数据；
    - CSRF：
      - Cookie的sameSite属性；
      - Token，放在cookie中；
      - 验证码；

    - sql注入
      - 使用参数化查询，使用？参数，不要直接拼接参数；
      - 参数校验；
      - 转义敏感字符；
      - 屏蔽出错信息；

14. 算法题：判断一个数组是否是回文数组；（5分钟）

    ```javascript
    function isRecicle(arr) {
      let n = arr.length
      if (n < 1) return true
      let str = arr.join('')
      let reverStr = arr.reverse().join('')
      return str === reverStr
    }
    ```

15. 算法题：求一个二维数组的所有笛卡尔积；（10分钟）

    ```javascript
    // 求笛卡尔积--遍历
    function dicarle(arr) {
      if (!Array.isArray(arr) || arr.length === 0 ) {
        return []
      }
      let last = [...arr[0]]
      for (let i = 1, n = arr.length; i < n; i++) {
        let temp = []
        for (let item1 of last) {
          for (let item2 of arr[i]) {
            temp.push(item1 + '' + item2)
          }
        }
        last = temp
      }
      return last
    }
    
    // 求笛卡尔积--递归
    function dicarle2(arr) {
      if (!Array.isArray(arr) || arr.length === 0 ) {
        return []
      }
      if (arr.length === 1) {
        return [...arr[0]]
      }
      if (arr.length === 2) {
        return merge(arr[0], arr[1])
      }
      let last = arr.pop()
      return merge(last, dicarle2(arr))
    
      function merge(arr1, arr2) {
        let temp = []
        for (let item1 of arr1) {
          for (let item2 of arr2) {
            temp.push(item1 + '' + item2)
          }
        }
        return temp
      }
    }
    
    // 求笛卡尔积--分治
    function dicarle3(arr, low, high) {
      if (!Array.isArray(arr) || arr.length === 0 ) {
        return []
      }
      let n = arr.length
      if (low >= high) {
        return arr[low]
      }
      let mid = low +  ((high - low) >> 1)
      let left = dicarle3(arr, low, mid)
      let right = dicarle3(arr, mid + 1, high)
      return merge(left, right)
    
      function merge(arr1, arr2) {
        let temp = []
        for (let item1 of arr1) {
          for (let item2 of arr2) {
            temp.push(item1 + '' + item2)
          }
        }
        return temp
      }
    }
    
    let arr = [[1,2,3], [4,5,1,2]]
    let result = dicarle(arr)
    let result2 = dicarle2(arr)
    let result3 = dicarle3(arr, 0, arr.length-1)
    console.log(result)
    console.log(result2)
    console.log(result3)
    
    ```

    

## Alibaba

### 国际化事业部

## JD
### taro


1. 介绍下项目；（回答思路：功能、技术栈、技术亮点）
2. 介绍下weex 实现原理；（分H5、Native两端）
3. weex sdk中如何把js生成native组件；
   答：weex sdk 三部分：JS执行环境（生成DOM,发送 Native DOM API），wxBridge（通信）,渲染引擎（原生渲染）
4. weex的bundle js 如何优化文件体积；（拆分成多个页面+压缩）
5. weex是否可以引用第三方js库；（js库可以用 ，UI库只能适配weex的可以）
6. H5项目中如何优化文件体积（webpack分析插件、提取第三方库、提取公共代码、tree-shaking、混淆、压缩）；
7. 第三库文件如何配置成单独chunk；（todo）
8. webpack打包后的文件是什么样的；
9.  打包后的第三方库文件，业务文件是如何使用的；
10. 介绍下AMD、CMD、ES6 Module、CommonJS等；
11. 介绍下http 缓存；
12. 协商缓存原理；
13. 介绍下promise；
14. Promise.all如何实现；

## 常见算法题

1. 两个大数相加

   ```javascript
   // 大数加法
   function add(num1, num2) {
       let arr1 = num1.split('')
       let arr2 = num2.split('')
       let add = 0
       let arr = []
       while (arr1.length || arr2.length) {
           let v1 = Number(arr1.pop() || '0')
           let v2 = Number(arr2.pop() || '0')
           let v = (v1 + v2 + add) % 10
           arr.unshift(v)
           add = Math.floor((v1 + v2 + add) / 10)
       }
       return arr.join('')
   }
   let num1 = '1999999'
   let num2 = '1'
   let result = add(num1, num2)
   console.log('result', result)
   ```

   ```javascript
   // 大数减法
   function sub(num1, num2) {
       let arr1 = num1.split('')
       let arr2 = num2.split('')
       let flag = 0
       let arr = []
       while (arr1.length || arr2.length) {
           let v1 = Number(arr1.pop() || '0')
           let v2 = Number(arr2.pop() || '0')
           let v = 0
           if (v1 - flag > v2) {
               v = v1 - flag - v2
               flag = 0
           } else {
               v = v1 + 10 - flag -v2
               flag = 1
           }
           arr.unshift(v)
       }
       return arr.join('')
   }
   
   let num1 = '2000000'
   let num2 = '1'
   let result = sub(num1, num2)
   console.log('result', result)
   ```

   

2. trim实现

   ```javascript
   // 数组实现
   function trim(str) {
       let arr = str.split('')
       while (arr.length)  {
           if (arr[0] === ' ') {
               arr.shift()
           }
           if (arr[arr.length - 1] === ' ') {
               arr.pop()
           }
           if (arr[0] !== ' ' && arr[arr.length-1] !== ' ') {
               break
           }
       }
       return arr.join('')
   }
   let str = '     sdfsd  '
   let result = trim(str)
   console.log(result, result.length)
   ```

   ```javascript
   // 正则实现
   function myTrim () {
       let str = this
       let reg = /(^\s*)|(\s*$)/g
       str = str.replace(reg, '')
       return str
   }
   String.prototype.myTrim = myTrim
   let str = '     sdfsd  '
   let result = str.myTrim()
   console.log(result, result.length)
   
   ```

   

3. xxx