# 数据结构与算法

## 如何学习

### 定义

- 数据结构：一组数据的存储结构；
- 算法：操作数据的一组方法；

### 学习技巧

1. 边学边练，适度刷题；
2. 多问、多思考、多互动；

### 时间复杂度

1. 表示算法的执行时间与数据规模之间的增长关系;
2. 只关注循环执行次数最多的代码，这段代码执行次数 n 的量级；
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积；

### 常见时间复杂度

- 多项式量级：O(1), O(logn), O(n), O(nlogn), O(n^k)
- 非多项式量级：O(2^n)、O(n!)

### 空间复杂度

1. 表示算法的存储空间与数据规模之间的增长关系；

### 常见空间复杂度

- O(1), O(n)，O(n^2)

### 4种时间复杂度

- 最好情况时间复杂度：代码在最好的情况下，循环部分执行次数；
- 最差情况时间复杂度：代码在最坏的情况下，循环部分执行次数；
- 平均时间复杂度：又称加权平均时间复杂度，各种情况求和概率*执行次数；
- 均摊时间复杂度：大部分情况下时间复杂度相同，特殊情况不同，所以把特殊情况均摊到大部分情况，即以大部分情况为准；

## 数据结构

### 数组

1. 定义：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组相同类型的数据；
2. 随机访问实现，一维数组内存寻址公式：a[i]_address = base_address + i * data_type_size
3. 二维数组的内存寻址公式： `a[i][j] = base_address + (i*n+j)*data_type_size`
4. javascript中Array实际上是一种高级数组结构，将很多数组操作的细节封装起来，如数组插入、移除、越界等判断；

```javascript
// 数组pop方法重写(push,shift,unshif同理)
function myPop() {
  let arr = this
  let n = arr.length
  // 注意边界
  if (n < 1) {
    return
  }
  let temp = arr[n-1]
  arr.length = n - 1
  return temp
}
Array.prototype.myPop = myPop
```

```javascript
/**
 * 数组splice方法重写
 * @param {Number} index 数组下标
 * @param {Number} num 删除数量
 * @param {Array} add 新增数组
 * @returns {Array} 返回删除的数组
 */
function mySplice(index, num, ...add) {
  let arr = this
  let n = arr.length
  if (n < 1) {
    return []
  }
  // 检查参数
  if (index > n - 1 || index + num > n) {
		return []
  }
  let del = []
  let before = []
  let after = []
  for (let i = 0; i < n; i++) {
		if (i < index) {
     before.push(arr[i])
    } else if (i < index + num) {
     del.push(arr[i])
    } else {
     after.push(arr[i])
    }
  }
  // 改变原数组
  let newArr = [...before, ...add, ...after]
  arr.length = newArr.length
  for (let i = index; i < newArr.length; i++) {
    arr[i] = newArr[i]
  }
  console.log('arr', arr)
 
  return del
}
Array.prototype.mySplice = mySplice
```



### 链表

1. 定义：通过一组零散的内存块串联使用；
2. 常见类型：单链表、双链表、循环链表；
3. 特点：链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高；
4. 链表代码技巧：
   - 理解指针或饮用含义；
   - 警惕指针丢失或内存泄漏；（先指向尾部，再连接）
   - 利用哨兵简化实现难度；
   - 留意边界条件处理；（null, 1个，2个，头尾等情况）
   - 举例画图；

```javascript
// 节点类
class Node {
  constructor (val) {
    this.val = val
    this.next = null
  }
}

// 单链表类
class LinkedList {
  constructor () {
    this.length = 0
    this.head = null
  }

  /**
   * 尾部添加一个元素
   * @param {*} val
   */
   push (val) {
     let node = new Node(val)
     if (this.length === 0) {
       this.head = node
       this.length++
       return
     }
     let current = this.head
     // 遍历链表，找到最后一项
     while (current.next) {
       current = current.next
     }
     current.next = node
     this.length++
   }

   /**
    * 尾部删除一项,返回删除的项
    * @returns {Node} 删除项
    */
    pop () {
      if (this.length === 0) {
        return null
      }

      let current = this.head
      let before = null
      // 遍历链表，找到最后一项
      while (current.next) {
        before = current
        current = current.next
      }
      before.next = null
      this.length--
      return current
    }

  /**
   * 头部添加一个元素
   * @param {*} val
   */
   unshift (val) {
     let node = new Node(val)
     if (this.length === 0) {
       this.head = node
       this.length++
       return this.length
     }

     let current = this.head
     node.next = current
     this.head = node
     this.length++
     return this.length
   }

   /**
    * 删除头部元素
    * @returns {Node} 返回删除的元素
    */
    shift () {
      if (this.length === 0) {
        return null
      }
      let current = this.head
      this.head = current.next
      this.length--
      return current
    }

    /**
     * 指定位置插入元素
     * @param {Number} position 插入位置下标
     * @param {*} val 插入的元素
     * @returns {Number} 链表长度
     */
     insert (position, val) {
       // 越界直接返回
       if (position < 0 || this.position > this.length) {
         return this.length
       }
       let node = new Node(val)
       let current = this.head
       let before = null
       let i = 0
       while (i < position) {
         before = current
         current = current.next
         i++
       }

       node.next = current
       before.next = node
       this.length++
       return this.length
     }

     /**
      * 指定位置删除节点
      * @param {Number} position
      * @returns {Node} 返回删除的节点
      */
      remove (position) {
        if (this.length === 0) {
          return null
        }
        if (position < 0 || position > this.length - 1) {
          return null
        }

        let current = this.head
        if (position === 0) {
          this.head = current.next
          this.length--
          return current
        }

        let before = null
        let i = 0
        // 遍历找到指定下标节点
        while (i < position) {
          before = current
          current = current.next
          i++
        }
        before.next = current.next
        this.length--
        return current
      }
}
```

### 栈

1. 定义：栈是一种操作受限的线性表，只允许在一端插入和删除操作；
2. 特点：先进后出，后进先出；
3. 类型：顺序栈，链式栈；
4. 入栈、出栈的时间复杂度都为O(1)；
5. 常见应用场景：浏览器路由、函数调用栈、表达式求值、括号匹配；

```javascript
// 浏览器路由--双栈
class router {
  constructor () {
    this.url = ''
    this.go = []
    this.back = []
  }

  // 路由加载
  add (url) {
    this.url = url
    this.go.push(url)
    return this.url
  }

  // 前进按钮
  foward () {
    if (this.back.length === 0) {
      return
    }
    let url = this.back.pop()
    this.go.push(url)
    this.url = url
    return this.url
  }

  // 后退按钮
  backaway () {
    if (this.go.length === 0) {
      return
    }
    const url = this.go.pop()
    this.back.push(url)
    this.url = this.go[this.go.length-1]
    return this.url
  }
}
```

```javascript
// 表达式求值 a+b*c
function getValue (exp) {
  // 数字栈
  let numStack = []
  // 运算符号栈
  let calStack = []
  // 运算符
  const o = ['+', '-', '*', '/']

  const n = exp.length
  let str = ''
  let i = 0
  while (i < n) {
    if (o.includes(exp[i])) {
      addCal(Number(str), exp[i])
      str = ''
    } else {
      str += exp[i]
    }
    i++
  }

  // 最后清空栈
  if (calStack.length) {
    let result = cal(numStack[0], Number(str), calStack[0])
    numStack[0] = result
  } else {
    numStack.push(Number(str))
  }

  return numStack[0]

  // 运算符入栈
  function addCal (num, exp) {
    if (calStack.length === 0) {
      numStack.push(num)
      calStack.push(exp)
      return
    }
    
    let expLevel = getLevel(exp)
    let lastLevel = getLevel(calStack[calStack.length - 1])

    if (lastLevel >= expLevel) {
      let result = cal(numStack[0], num, calStack[0])
      numStack.push(result)
      calStack.pop()
      calStack.push(exp)
    } else {
      numStack.push(num)
      calStack.push(exp)
    }
  }

  function getLevel (exp) {
    let level = {
      '+': 0,
      '-': 0,
      '*': 1,
      '/': 1
    }
    return level[exp]
  }

  // 表达式求值
  function cal (num1, num2, exp) {
    // case +,-,*,/
    return eval(`${num1}${exp}${num2}`)
  }

}
```

### 队列

1. 定义：先进先出的一种数据结构；
2. 只支持两种操作：入队和出队；
3. 类型：顺序队列，链式队列，循环队列，阻塞队列，并发队列；
4. 应用场景：线程池，数据库连接池，消息队列

```javascript
// 循环队列
class CircularQueue {
  constructor (length) {
    this.list = []
    this.length = length
    this.head = 0
    this.tail = 0
  }
  /**
   * 入队
   */
  enqueue (item) {
    // 队列满了
    if ((this.tail + 1) % this.length === this.head) {
      return false
    }
    this.list[this.tail] = item
    this.tail = (this.tail + 1) % this.length
    return true
  }

  /**
   * 出队
   */
  dequeue () {
    // 队列为空
    if (this.tail === this.head) {
      return null
    }
    const result = this.list[this.head]
    this.head = (this.head + 1) % this.length
    return result
  }
}

```

## 算法

### 排序

1. 归并排序

   - 时间复杂度 ：最好，最坏，平均都是O(nlogn)；
   - 空间复杂度：O(n)
   - 稳定性：稳定

   ```javascript
   // 归并排序--分治思想
   function mergeSort(arr, start = 0, end = arr.length - 1) {
     // 终止条件，start >= end
     if (start >= end) return
     
     // 分解，0, end/2; end/2+1, end
     let center = Math.floor((start + end)/2)
     mergeSort(arr, start, center)
     mergeSort(arr, center+1, end)
     
     // 合并两个有序数组，重新排序
     let arr1 = arr.slice(start, center+1)
     let arr2 = arr.slice(center+1, end+1)
     merge(arr, arr1, arr2, start)
   }
   
   // 合并两个有序数组
   function merge(arr, arr1, arr2, start) {
     let temp = []
     while (arr1.length && arr2.length) {
   		if (arr1[0] < arr2[0]) {
         temp.push(arr1.shift())
       } else {
         temp.push(arr2.shift())
       }
     }
     if (arr1.length) {
       temp.push(...arr1)
     }
     if (arr2.length) {
       temp.push(...arr2)
     }
     console.log('temp', temp)
     for (let i = 0, n = temp.length; i < n; i++) {
       arr[start+i] = temp[i]
     }
   }
   ```

   2. 快速排序

      - 时间复杂度：最好O(nlogn)、最坏O(n^2)、平均O(nlogn)
      - 空间复杂度：O(1)
      - 稳定性：不稳定

      ```javascript
      // 快速排序 -- 递归
      function quickSort(arr, start = 0, end = arr.length - 1) {
        // 终止条件， start >= end
        if (start >= end) return
        
        // 获取分区点
        let p = partition(arr, start, end)
        quickSort(arr, start, p-1)
        quickSort(arr, p+1, end)
      }
      
      // 分区函数，找到分区点, O(n) 
      function partition(arr, start, end) {
        let p = end, value = arr[end]
        let j = start  // 分区前一个下标
        for (let i = start, n = end + 1; i < n; i++) {
          // 小于分区值得移到左边
          if (arr[i] < value) {
            [arr[i], arr[j]] = [arr[j], arr[i]]
            j++
          }
        }
        // 分区值移动指定位置
        [arr[j], arr[p]] = [arr[p], arr[j]]
        return j
      }
      ```



## 动态规划

### 斐波那契数列

描述：1,1,2,3,5,8...

```javascript
// 递归 O(2^n)
function fb (n) {
  if (n < 3) {
	return 1
  }
  return fb(n-1) + fb(n-2)
}

// 递归优化（空间换时间）O(n)
function fb (n) {
  // 实际执行函数
  function f (amount) {
    if (amount < 3) {
      return 1
    }
    if (cache[amount]) {
      return cache[amount]
    }
    cache[amount] = f(amount-1) + f(amount-2)
    console.log('cache[amount]', cache[amount])
    return cache[amount]
  }
  // 缓存计算结果
  const cache = []
  return f(n)
}
```

```javascript
/**
 * 尾递归 O(n)
 * @param {Number} f1 第一项值
 * @param {Number} f2 第二项值
 * @param {Number} n 第n次
 */
function fb (f1, f2, n) {
  if (n === 1 ) {
      return f1
  }
  return fb(f2, f1+f2, n-1)
}
```

```javascript
// 遍历 o(n)
function fb (n) {
  if ( n < 3) {
    return 1
  }
  let s = 0
  let a = 1
  let b = 1
  for (let i = 2; i < n; i++) {
    s = a + b
    a = b
    b = s
  }

  return s
}
```

```javascript
// 动态规划 O(n) 
function fb (n) {
  const cache = [1, 2]
  for (let i = 2; i <= n; i++) {
    cache[i] = cache[i-1] + cache[i-2]
  }
  return cache[n]
}
```

```javascript
// 斐波那契通项公式
function fb(n) {
  return (((1+Math.sqrt(5))/2)^n - ((1-Math.sqrt(5))/2)^n)/Math.sqrt(5)
}
```



### 找零问题

描述：一个算法星球央行发布了奇葩币，币值分别为1,5,11，求最少多少个硬币凑成n元；

```javascript
// 递归 O(3^n)
function f (n) {
  let min = Infinity
  if (n < 0) {
    return min
  }
  if (n === 0) {
    return 0
  }
  min = Math.min(f(n-1) + 1, f(n-5) + 1, f(n-11) + 1)
  return min
}
```

``` javascript
// 递归优化 （空间换时间）O(n)
// 缺陷：依然会爆栈
function f(n) {
  function g(m) {
    let min = Infinity
    if (cache[m]) {
      return cache[m]
    }
    if (m < 0) {
      return min
    }
    if (m === 0) {
      return 0
    }
    // 注意函数名字易错
    min = Math.min(g(m-1) + 1, g(m-5) + 1, g(m-11) + 1)
    cache[m] = min
    return min
  }
  const cache = []
  return g(n)
}
```

```javascript
// 动态规划 O(n)
function f(n) {
  // 初始缓存为最大值   
  const cache = new Array(n+1).fill(Infinity)
  if (n < 0) {
    return Infinity
  }
  cache[0] = 0
  for (let i = 1; i <= n; i++) {
    // 推导公式：fn = Math.min(fn-1, fn-5, fn-11) + 1
    if (i - 5 < 0) {
	  cache[i] = cache[i-1] + 1
    } else if (i - 11 < 0) {
      cache[i] = Math.min(cache[i-1], cache[i-5]) + 1
    } else {
      cache[i] = Math.min(cache[i-1], cache[i-5], cache[i-11]) + 1
    }
  }
  return cache[n]
}
```

```javascript
// 描述：给出不同面额硬币coins和一个总金额n, 求凑成总金额n的最小硬币数；
// 动态规划 O(coins.length * n)
function f(coins, n) {
  // 初始缓存为最大值   
  const cache = new Array(n+1).fill(Infinity)
  if (n < 0) {
    return Infinity
  }
  cache[0] = 0
  for (let i = 1; i <= n; i++) {
    // 推断公式：fn = Math.min(f[n-ci]) + 1
    for (const coin of coins) {
      if (coin <= i) {
        cache[i] = Math.min(cache[i], cache[i-coin] + 1)
      }
     }
   }
   return cache[n] === Infinity ? -1 : cache[n]
}
```

### 国王与金矿

有一个国家发现了5座金矿，挖矿工人10个。每座金矿要么全挖，要么不挖。要想得到尽可能多的黄金，应该挖哪几座金矿？

金矿数组：500金/5人，400金/5人，350金/3人，300金/4人，200金/3人

```javascript
/**
 * 挖矿选择 -- 递归法
 * @param {Number} m 金矿数量
 * @param {Number} n 工人数量
 * @param {Array} g 所需工人（数）
 * @param {Array} h 金矿产量（金）
 * @returns {Number} 最多挖矿金额
 */
function f (m, n, g, h) {
  if (m <= 0 || n <= 0) {
		return 0
	}
  // 工人数不够
  if (n < g[m-1]) {
    return 0
 	}
  
  // 只有一座金矿
	if (m === 1) {
    return n >= g[0] ? h[0] : 0
	}
  // 挖与不挖
	let did = f(m-1, n-g[m-1], g, h) + h[m-1]
	let noDid = f(m-1, n, g, h)
  return Math.max(did, noDid)
}
```



## 树

### 二叉树

1. 定义

   ```javascript
   function Node (value) {
   	this.value = value
     this.left = null
     this.right = null
   }
   ```

2. 前序遍历

   ```javascript
   // 前序遍历--递归
   function preFn(node, cb) {
     if (!node) {
       return
     }
     if (node && node.value) {
   		cb(node.value)
     }
     preFn(node.left, cb)
     preFn(node.right, cb)
   }
   ```

   ```javascript
   // 前序遍历--非递归
   function preFn(node, cb) {
     let q = []
     while (node || q.length) {
       while (node) {
         q.push(node)
         cb(node.value)
         node = node.left
       }
       node = q.pop()
       node = node.right
     }
   }
   ```

   ```javascript
   // 测试例子
   var node = {
     value: 'G',
     left: {
       value: 'D',
       left: {
         value: 'A'
       },
       right: {
   			value: 'F',
       	left: {
   				value: 'E'
         }
       }
     },
     right: {
   		value: 'M',
       left: {
   			value: 'H'
       },
       right: {
   			value: 'Z'
       }
     }
   }
   var result = []
   function cb(value) {
     result.push(value)
   }
   ```
   
3. 中序遍历

   ```javascript
   // 中序遍历 -- 递归法
   function cenFn (node, cb) {
   	if (!node) {
       return
     }
     cenFn(node.left, cb)
     cb(node.value)
   	cenFn(node.right, cb)
   }
   ```

   ``` javascript
   // 中序遍历 -- 非递归
   function cenFn (node, cb) {
     let stack = []
     while (node || stack.length) {
       // 左子树入栈
       while (node) {
         stack.push(node)
         node = node.left
       }
       // 弹出最后一个入栈节点
       node = stack.pop()
       cb(node.value)
       // 遍历右子树
       node = node.right
     }
   }
   ```

4. 后序遍历

   ```javascript
   // 后序遍历 -- 递归法
   function lastFn (node, cb) {
		if (!node) {
   		return
    }
     lastFn(node.left, cb)
     lastFn(node.right, cb)
     cb(node.value)
   }
   ```
   ```javascript
   // 后序遍历 -- 非递归
function lastFn (node, cb) {
    let stack = []
    let result = []
     while (node || stack.length) {
       result.push(node.value)
     	if (node.left) {
         stack.push(node.left)
       }
       if (node.right) {
         stack.push(node.right)
       }
   		node = stack.pop()
     }
    while (result.length) {
    cb(result.pop())
     }
   }
   ```
   

### 普通树

1. 广度优先遍历
   - 定义：逐层遍历
   
   - 实现：
   
     ```javascript
     // 广度优先遍历 -- 递归 (待优化)
     function dfs(node, result = []) {
     	if (node && node.length) {
     		for (let i = 0, n = node.length; i < n; i++) {
     			result.push(node[i].value);
     		}
     		for (let j = 0, n = node.length; j < n; j++) {
     			dfs(node[j].children, result)
     		}
     	}
     	return result;
     }
     ```
   ```javascript
   // 广度优先遍历 -- 非递归
   function bfs (node, result = []) {
     let stack = []
     while (node || stack.length) {
       result.push(node.value)
       if (node.children) {
       	for (let i = 0, n = node.children.length; i < n; i++) {
           stack.push(node.children[i])
         }
       }
       node = stack.shift()
     }
     return result
   }
   ```
   
     ```javascript
     // 测试例子
     let node = {
       value: 'A',
       children: [
         {
           value: 'B',
           children: [
             {
               value: 'F'
             }
           ]
         },
         {
           value: 'C',
           children: [
             {
               value: 'D'
             },
             {
               value: 'E'
             }
           ]
         }
       ]
     }
     
     let result = []
     bfs(node, result)
     console.log(new Date.toLocaleString(), 'result', result)
     ```
   
2. 深度优先遍历
   - 定义：自上而下
   - 实现：

   ``` javascript
   // 深度优先遍历 -- 递归
   function dfs(node, result = []) {
     if (!node) {
       for (let i = 0, n = node.childern.length; i < n; i++) {
         result.push(node.value)
       }
       bfs(node.children)
     }
     return result
   }
   ```

   ```javascript
   // 深度优先遍历 -- 非递归
   function dfs(node, result = []) {
     let stack = []
     while (node || stack.length) {
       result.push(node.value)
       if (node.children) {
         for (let n = node.children.length, i = n - 1; i >= 0; i--) {
           stack.push(node.children[i])
         }
       }
       node = stack.pop()    
     }
     return result
   }
   ```

   ## 正则

   ### 正则语法

   1. 元字符

      - `^ `: 匹配字符串开始；
      - `$`:匹配字符串结束；
      - `.`:匹配除换行符之外所有字符；
      - `\s`: 匹配任意空白字符；
      - `\w`: 匹配字母，数字，下划线；
      - `|`：或匹配，如 a|b； 
      - `\b`: 匹配单词边界；
      - `\d`: 匹配数字，等同于[0-9]

   2. 反义字符

      - `[^x]`: 匹配除字符x以外的所有字符；

   3. 重复匹配

      - `*`： >=0 重复任意次数；
      - `?`: 0次或者1次；
      - +： >=1 次数；
      - {n}: 重复出现n次；

   4. 分组

      - `(exp)`: 小圆括号进行分组

   5. 修饰符

      - `i`： ignoreCase, 忽略字母的大小写；

      - `g`: global， 进行全局匹配；

      - `m`： multi line, 多行匹配；

        

   ### 正则经典例子

   1. js实现trim，去除首尾空白字符

      ```javascript
      function myTrim () {
        let str = this
        let reg = /(^\s*)|(\s*$)/g
        str = str.replace(reg, '')
        return str
      }
      String.prototype.myTrim = myTrim
      ```

   2. js判断一个字符串是否是正确的符号嵌套匹配，如[],{},()

      ```javascript
      function isRight()
      ```

      

   3. xx

   4. xx

   