# 数据结构与算法

## 如何学习

### 定义

- 数据结构：一组数据的存储结构；
- 算法：操作数据的一组方法；

### 学习技巧

1. 边学边练，适度刷题；
2. 多问、多思考、多互动；
3. 考查优先级：二分法、拓扑排序、哈希表、二叉查找树、动态规划、分治法、堆、贪心、最小生成树、字典树、并查集等；

### 时间复杂度

1. 表示算法的执行时间与数据规模之间的增长关系;
2. 只关注循环执行次数最多的代码，这段代码执行次数 n 的量级；
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积；

### 常见时间复杂度

- 多项式量级：O(1), O(logn), O(n), O(nlogn), O(n^k)
- 非多项式量级：O(2^n)、O(n!)

### 空间复杂度

1. 表示算法的存储空间与数据规模之间的增长关系；

### 常见空间复杂度

- O(1), O(n)，O(n^2)

### 4种时间复杂度

- 最好情况时间复杂度：代码在最好的情况下，循环部分执行次数；
- 最差情况时间复杂度：代码在最坏的情况下，循环部分执行次数；
- 平均时间复杂度：又称加权平均时间复杂度，各种情况求和概率*执行次数；
- 均摊时间复杂度：大部分情况下时间复杂度相同，特殊情况不同，所以把特殊情况均摊到大部分情况，即以大部分情况为准；

## 数据结构

### 数组

1. 定义：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组相同类型的数据；
2. 随机访问实现，一维数组内存寻址公式：a[i]_address = base_address + i * data_type_size
3. 二维数组的内存寻址公式： `a[i][j] = base_address + (i*n+j)*data_type_size`
4. javascript中Array实际上是一种高级数组结构，将很多数组操作的细节封装起来，如数组插入、移除、越界等判断；

```javascript
// 数组pop方法重写(push,shift,unshif同理)
function myPop() {
  let arr = this
  let n = arr.length
  // 注意边界
  if (n < 1) {
    return
  }
  let temp = arr[n-1]
  arr.length = n - 1
  return temp
}
Array.prototype.myPop = myPop
```

```javascript
/**
 * 数组splice方法重写
 * @param {Number} index 数组下标
 * @param {Number} num 删除数量
 * @param {Array} add 新增数组
 * @returns {Array} 返回删除的数组
 */
function mySplice(index, num, ...add) {
  let arr = this
  let n = arr.length
  if (n < 1) {
    return []
  }
  // 检查参数
  if (index > n - 1 || index + num > n) {
		return []
  }
  let del = []
  let before = []
  let after = []
  for (let i = 0; i < n; i++) {
		if (i < index) {
     before.push(arr[i])
    } else if (i < index + num) {
     del.push(arr[i])
    } else {
     after.push(arr[i])
    }
  }
  // 改变原数组
  let newArr = [...before, ...add, ...after]
  arr.length = newArr.length
  for (let i = index; i < newArr.length; i++) {
    arr[i] = newArr[i]
  }
  console.log('arr', arr)
 
  return del
}
Array.prototype.mySplice = mySplice
```



### 链表

1. 定义：通过一组零散的内存块串联使用；
2. 常见类型：单链表、双链表、循环链表；
3. 特点：链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高；
4. 链表代码技巧：
   - 理解指针或饮用含义；
   - 警惕指针丢失或内存泄漏；（先指向尾部，再连接）
   - 利用哨兵简化实现难度；
   - 留意边界条件处理；（null, 1个，2个，头尾等情况）
   - 举例画图；

```javascript
// 节点类
class Node {
  constructor (val) {
    this.val = val
    this.next = null
  }
}

// 单链表类
class LinkedList {
  constructor () {
    this.length = 0
    this.head = null
  }

  /**
   * 尾部添加一个元素
   * @param {*} val
   */
   push (val) {
     let node = new Node(val)
     if (this.length === 0) {
       this.head = node
       this.length++
       return
     }
     let current = this.head
     // 遍历链表，找到最后一项
     while (current.next) {
       current = current.next
     }
     current.next = node
     this.length++
   }

   /**
    * 尾部删除一项,返回删除的项
    * @returns {Node} 删除项
    */
    pop () {
      if (this.length === 0) {
        return null
      }

      let current = this.head
      let before = null
      // 遍历链表，找到最后一项
      while (current.next) {
        before = current
        current = current.next
      }
      before.next = null
      this.length--
      return current
    }

  /**
   * 头部添加一个元素
   * @param {*} val
   */
   unshift (val) {
     let node = new Node(val)
     if (this.length === 0) {
       this.head = node
       this.length++
       return this.length
     }

     let current = this.head
     node.next = current
     this.head = node
     this.length++
     return this.length
   }

   /**
    * 删除头部元素
    * @returns {Node} 返回删除的元素
    */
    shift () {
      if (this.length === 0) {
        return null
      }
      let current = this.head
      this.head = current.next
      this.length--
      return current
    }

    /**
     * 指定位置插入元素
     * @param {Number} position 插入位置下标
     * @param {*} val 插入的元素
     * @returns {Number} 链表长度
     */
     insert (position, val) {
       // 越界直接返回
       if (position < 0 || this.position > this.length) {
         return this.length
       }
       let node = new Node(val)
       let current = this.head
       let before = null
       let i = 0
       while (i < position) {
         before = current
         current = current.next
         i++
       }

       node.next = current
       before.next = node
       this.length++
       return this.length
     }

     /**
      * 指定位置删除节点
      * @param {Number} position
      * @returns {Node} 返回删除的节点
      */
      remove (position) {
        if (this.length === 0) {
          return null
        }
        if (position < 0 || position > this.length - 1) {
          return null
        }

        let current = this.head
        if (position === 0) {
          this.head = current.next
          this.length--
          return current
        }

        let before = null
        let i = 0
        // 遍历找到指定下标节点
        while (i < position) {
          before = current
          current = current.next
          i++
        }
        before.next = current.next
        this.length--
        return current
      }
}
```

### 栈

1. 定义：栈是一种操作受限的线性表，只允许在一端插入和删除操作；
2. 特点：先进后出，后进先出；
3. 类型：顺序栈，链式栈；
4. 入栈、出栈的时间复杂度都为O(1)；
5. 常见应用场景：浏览器路由、函数调用栈、表达式求值、括号匹配；

```javascript
// 浏览器路由--双栈
class router {
  constructor () {
    this.url = ''
    this.go = []
    this.back = []
  }

  // 路由加载
  add (url) {
    this.url = url
    this.go.push(url)
    return this.url
  }

  // 前进按钮
  foward () {
    if (this.back.length === 0) {
      return
    }
    let url = this.back.pop()
    this.go.push(url)
    this.url = url
    return this.url
  }

  // 后退按钮
  backaway () {
    if (this.go.length === 0) {
      return
    }
    const url = this.go.pop()
    this.back.push(url)
    this.url = this.go[this.go.length-1]
    return this.url
  }
}
```

```javascript
// 表达式求值 a+b*c
function getValue (exp) {
  // 数字栈
  let numStack = []
  // 运算符号栈
  let calStack = []
  // 运算符
  const o = ['+', '-', '*', '/']

  const n = exp.length
  let str = ''
  let i = 0
  while (i < n) {
    if (o.includes(exp[i])) {
      addCal(Number(str), exp[i])
      str = ''
    } else {
      str += exp[i]
    }
    i++
  }

  // 最后清空栈
  if (calStack.length) {
    let result = cal(numStack[0], Number(str), calStack[0])
    numStack[0] = result
  } else {
    numStack.push(Number(str))
  }

  return numStack[0]

  // 运算符入栈
  function addCal (num, exp) {
    if (calStack.length === 0) {
      numStack.push(num)
      calStack.push(exp)
      return
    }
    
    let expLevel = getLevel(exp)
    let lastLevel = getLevel(calStack[calStack.length - 1])

    if (lastLevel >= expLevel) {
      let result = cal(numStack[0], num, calStack[0])
      numStack.push(result)
      calStack.pop()
      calStack.push(exp)
    } else {
      numStack.push(num)
      calStack.push(exp)
    }
  }

  function getLevel (exp) {
    let level = {
      '+': 0,
      '-': 0,
      '*': 1,
      '/': 1
    }
    return level[exp]
  }

  // 表达式求值
  function cal (num1, num2, exp) {
    // case +,-,*,/
    return eval(`${num1}${exp}${num2}`)
  }

}
```

### 队列

1. 定义：先进先出的一种数据结构；
2. 只支持两种操作：入队和出队；
3. 类型：顺序队列，链式队列，循环队列，阻塞队列，并发队列；
4. 应用场景：线程池，数据库连接池，消息队列

```javascript
// 循环队列
class CircularQueue {
  constructor (length) {
    this.list = []
    this.length = length
    this.head = 0
    this.tail = 0
  }
  /**
   * 入队
   */
  enqueue (item) {
    // 队列满了
    if ((this.tail + 1) % this.length === this.head) {
      return false
    }
    this.list[this.tail] = item
    this.tail = (this.tail + 1) % this.length
    return true
  }

  /**
   * 出队
   */
  dequeue () {
    // 队列为空
    if (this.tail === this.head) {
      return null
    }
    const result = this.list[this.head]
    this.head = (this.head + 1) % this.length
    return result
  }
}

```

## 基础算法

### 递归

1. 什么类型问题适合递归求解

   - 一个问题可以分解为几个子问题；
   - 子问题与父问题求解方法一样；
   - 存在递归终止条件；

2. 如何编码递归问题

   - 写出递推公式；
   - 写出终止条件；
   - 翻译成代码；

3. 递归代码弊端及解决方法

   - 堆栈溢出：通过控制递归深度；
   - 重复计算：通过散列表存储计算值；
   - 函数调用耗时多：通过控制递归深度；
   - 空间复杂度高：转成非递归；

4. 经典例子

   ```javascript
   // 爬楼梯：一次可以爬1层或者2层，问爬到n层有多少种方法
   // 递归: fn = fn-1 + fn-2, f1 = 1, f2 = 2
   // 时间复杂度 O(n), 空间复杂度 O(1)
   function f(n) {
     if (n === 1) return 1
     if (n === 2) return 2
     return f(n-1) + f(n-2)
   }
   
   // 递归优化：散列表存储计算的值
   // 时间复杂度 O(n), 空间复杂度 O(n)
   function f(n) {
     let map = new Map()
     return g(n)
     function g(n) {
       if (map.has(n)) return map.get(n)
       if (n === 1) return 1
       if (n === 2) return 2
       let temp = g(n-1) + g(n-2)
       map.set(n, temp)
       return temp
     }
   }
   
   // 非递归
   // 时间复杂度 O(n), 空间复杂度 O(1)
   function f(n) {
     let sum = 0, a = 1, b = 2
     if (n === 1) return 1
     if (n === 2) return 2
     for (let i = 3; i <= n; i++) {
       sum = a + b
       a = b
       b = sum
     }
     return sum
   }
   
   // 动态规划
   function f(n) {
     let dp = [1, 2]
     for (let i = 2; i < n; i++) {
   		dp[i] = dp[i-1] + dp[i-2]
     }
     return dp[n-1]
   }
   ```

  ### 排序

1. 常见排序算法分类

   - O(n^2):  冒泡、插入、选择；
   - O(nlogn): 快排、归并； 
   - O(n): 桶、计数、基数；

2. 如何分析排序算法

   - 时间复杂度，最好、最坏、平均；
   - 比较次数和交换次数；
   - 排序的稳定性，利于实际应用场景；如按照订单时间、金额排序；

3. 冒泡排序

   - 时间复杂度:  平均O(n^2)，最好O(n), 最坏O(n^2)
   - 稳定性：稳定

   ```javascript
   // 冒泡排序(从小到大，下标0开始)
   function bubbleSort(arr) {
   	let n = arr.length
     if (n <= 1) return
     for (let i = 0; i < n; i++) {
    		// 标志提前退出冒泡循环
       let change = false
       for (let j = 0; j < n - i - 1; j++) {
         if (arr[j] > arr[j+1]) {
   				[arr[j], arr[j+1]] = [arr[j+1], arr[j]]
           change = true
         }
       }
    		// 若当前循环没有移动元素，则已经排序完成   
       if (!change) break
     }
   }
   ```

4. 插入排序

   - 时间复杂度：平均O(n^2)、最好O(n)、最坏O(n^2)
   - 稳定性：稳定

   ```javascript
   // 插入排序
   function insertSort(arr) {
     let n = arr.length
     if (n <= 1) return
     for (let i = 1; i < n; i++) {
       let temp = arr[i]
       for (let j = i - 1; j >= 0; j--) {
         // 当目标值小的时候，需要移动
   	    if (temp < arr[j]) {
           arr[j+1] = arr[j]
         } else {
           // 否则，插入元素
           arr[j+1] = temp
           break
         }
       }
     }
   }
   ```
   
5. 归并排序

   - 时间复杂度 ：最好，最坏，平均都是O(nlogn)；
   - 空间复杂度：O(n)
   - 稳定性：稳定

   ```javascript
   // 归并排序--分治思想
   function mergeSort(arr, start = 0, end = arr.length - 1) {
     // 终止条件，start >= end
     if (start >= end) return
     
     // 分解，0, end/2; end/2+1, end
     let center = Math.floor((start + end)/2)
     mergeSort(arr, start, center)
     mergeSort(arr, center+1, end)
     
     // 合并两个有序数组，重新排序
     let arr1 = arr.slice(start, center+1)
     let arr2 = arr.slice(center+1, end+1)
     merge(arr, arr1, arr2, start)
   }
   
   // 合并两个有序数组
   function merge(arr, arr1, arr2, start) {
     let temp = []
     while (arr1.length && arr2.length) {
   		if (arr1[0] < arr2[0]) {
         temp.push(arr1.shift())
       } else {
         temp.push(arr2.shift())
       }
     }
     if (arr1.length) {
       temp.push(...arr1)
     }
     if (arr2.length) {
       temp.push(...arr2)
     }
     console.log('temp', temp)
     for (let i = 0, n = temp.length; i < n; i++) {
       arr[start+i] = temp[i]
     }
   }
   ```
   
6. 快速排序

   - 时间复杂度：最好O(nlogn)、最坏O(n^2)、平均O(nlogn)
   - 空间复杂度：O(1)
   - 稳定性：不稳定
- 如何优化：分区算法优化，如三数取中；
  
   ```javascript
    // 快速排序 -- 递归
    function quickSort(arr, start = 0, end = arr.length - 1) {
      // 终止条件， start >= end
      if (start >= end) return
      // 获取分区点
      let p = partition(arr, start, end)
      quickSort(arr, start, p-1)
      quickSort(arr, p+1, end)
    }

    // 分区函数，找到分区点, O(n) 
    function partition(arr, start, end) {
      let p = end, value = arr[end]
      let j = start  // 分区前一个下标
      for (let i = start, n = end + 1; i < n; i++) {
        // 小于分区值得移到左边
        if (arr[i] < value) {
          [arr[i], arr[j]] = [arr[j], arr[i]]
          j++
        }
      }
      // 分区值移动指定位置
      [arr[j], arr[p]] = [arr[p], arr[j]]
      return j
    }
   ```
   
   ```javascript
   // 快速排序--双指针法
   function quickSort(arr, begin = 0, end = arr.length - 1) {
     // 只有一个元素退出
     if (begin >= end) return
     // 基准数：左边第一个
     let base = arr[begin], l = begin, r = end
     // 双指针移动，分出左右两边  
     while (r > l) {
       // 移动右指针，从右往左
       while (r > l && arr[r] >= base) {
         r--
       }
       // 移动左指针，从左往右
       while (r > l && arr[l] <= base) {
         l++
       }
       // 交换指针对应的值
       [arr[l], arr[r]] = [arr[r], arr[l]]
     }
     // 交换基准
     [arr[begin], arr[l]] = [arr[l], arr[begin]]
     // 递归左右两边
     quickSort(arr, begin, l-1)
     quickSort(arr, l+1, end)
   }
   ```
   
   ```javascript
   // 查找第K大的元素   时间复杂度要求O(n)
   function findK(arr, k) {
     let n = arr.length
     if (k > n) return -1
     // 分区
     let p = partition(arr, 0, n-1)
     // 递归，直至找到 p + 1 = k
     while (p+1 !== k) {
       if (p+1 > k) {
         p = partition(arr, 0, p-1)
       } else {
         p = partition(arr, p+1, n-1)
       }
     }
     return arr[p]
   }
   // 分区函数
   function partition(arr, start, end) {
     let base = arr[end] // 基准数
     let j = start // 表示基准数左边一位
     for (let i = start; i < end; i++) {
       if (arr[i] < base) {
         [arr[i], arr[j]] = [arr[j], arr[i]]
         j++
       }
     }
     // 交换分区 
   	[arr[j], arr[end]] = [arr[end], arr[j]]
     return j
   }
   ```
   
7. 桶排序

   - 定义：将一定范围划分成一个桶，对桶内元素排序，然后整合每个桶中的数据；

   - 时间复杂度：最好O(n)、最坏O(nlogn)、平均O(n)
   - 空间复杂度：O(1)
   - 稳定性：取决于内部排序算法，一般为快排，不稳定；
   - 应用场景：范围不大的数据类型，外部排序中，桶的数量接近n；

   ```javascript
   // 桶排序
   // 思路：桶划分，桶内排序，整合在一起
   function bucketSort(arr) {
     if (arr.length < 2) return arr
     let bucketSize = 5
     const buckets = createBuckets(arr, bucketSize)
     return sortBuckets(buckets)
   }
   
   // 创建桶
   function createBuckets(arr, bucketSize) {
     let minValue = Math.min(arr)
     let maxValue = Math.max(arr)
     
     // 计算桶的个数
     const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1
     // 建立一个二维数组，存放桶
     const buckets = []
     for (let i = 0; i < bucketCount; i++) {
       buckets[i] = []
     }
     // 计算每一个值应该放在哪一个桶中
     for (let i = 0; i < arr.length; i++) {
       const bucketIndex = Math.floor((arr[i] - minValue) / bucketSize)
       buckets[bucketIndex].push(arr[i])
     }
     return buckets
   }
   
   // 桶内排序
   function sortBuckets(buckets) {
     const sortedArray = []
     for (let i = 0; i < buckets.length; i++) {
       if (buckets[i] != null) {
         // 插入排序, 见前面
         insertSort(buckets[i])
         sortedArray.push(...buckets[i])
       }
     }
   }
   ```

   

8. 计数排序

   - 定义：计数排序是桶排序的一种特殊情况，当数据范围不大时；

   - 时间复杂度：平均O(n)
   - 空间复杂度：O (1)
   - 稳定性：稳定；
   - 应用场景：50万考生排名，分数只有0-750分；

   ```javascript
   // 计数排序
   function  countingSort(arr) {
     let n = arr.length
     if (n < 1) return
     
     const max = Math.max(...arr)
     const counts = new Array(max+1)
     
     // 遍历数组，下标是元素，值是元素个数
     arr.forEach(item => {
       if (!counts[item]) {
         counts[item] = 0
       }
       counts[item]++
     })
     
     let sortedIndex = 0
     counts.forEach((count, i) => {
       while(count > 0) {
         arr[sortedIndex] = i
         sortedIndex++
         count--
       }
     })
   }
   ```

9. 基数排序

   - 定义：
   - 时间复杂度：平均O(n)
   - 空间复杂度：O(1)
   - 稳定性：稳定
   - 应用场景：10万个手机号码排序；

### 二分查找

1. 定义：针对有序数据的高效查找算法，时间复杂度O(logn)

2. 经典例子：

   ```javascript
   // 二分查找--非递归
   function bsearch(arr, val) {
     let low = 0, high = arr.length - 1
     // 注意是 low<=high，而不是 low
     while (low <= high) {
       // 高效除2
       let mid = (low + high) >> 1
       if (arr[mid] === val) {
         return mid
       } else if (arr[mid] < val) {
         low = mid + 1
       } else {
         high = mid - 1
       }
     }
     return -1
   }
   ```

   ```javascript
   // 二分查找--递归
   function bsearch(arr, val) {
     let low = 0, high = arr.length - 1
     return fn(arr, low, high, val)
     // 递归函数
     function fn(arr, low, high, val) {
       if (low > high) return -1
       let mid = (low + high) >> 1
       if (arr[mid] === val) {
         return mid
       } else if (arr[mid] < val) {
         return fn(arr, mid+1, high, val)
       } else {
         return fn(arr, low, mid-1, val)
       }
     }
   }
   ```

3. 二分查找变形

   ```javascript
   // 查找第一个值等于给定值的元素
   function getFirstOne(arr, value) {
     let low = 0, high = arr.length -1
     while (low <= high) {
       let mid = low + ((high - low) >> 1)
       if (arr[mid] > value) {
         high = mid -1
       } else if (arr[mid] < value) {
         low = mid + 1
       } else {
         // mid = 0表示第一个，就不用再找了
         if (mid === 0 || arr[mid-1] !== value) {
           return mid
         } else {
           high = mid - 1
         }
       }
     }
     return -1
   }
   ```

   ```javascript
   // 查找最后一个值等于给定值的元素
   function getLastOne(arr, value) {
     let low  = 0, high = arr.length - 1
     while (low <= high) {
       let mid = low + ((high - low) >> 1)
       if (arr[mid] < value) {
         low = mid + 1
       } else if (arr[mid] > value) {
         high = mid - 1
       } else {
         if (mid === arr.length - 1 || arr[mid+1] !== value) {
           return mid
         }
         low = mid + 1
       }
     }
     return -1
   }
   ```

   ```javascript
   // 查找第一个大于等于给定值的元素
   function getFirstMaxOne(arr, value) {
     let low = 0, high = arr.length - 1
     while (low <= high) {
       let mid = low + ((high - low) >> 1)
       if (arr[mid] < value) {
         low = mid + 1
       } else {
         if (mid === 0 || arr[mid-1] < value) {
           return mid
         }
         high = mid - 1
       }
     }
     return -1
   }
   ```

   ```javascript
   // 查找最后一个小于等于给定值的元素
   function getLastMinOne(arr, value) {
     let low = 0, high = arr.length - 1
     while (low <= high) {
       let mid = low + ((high - low) >> 1)
       if (arr[mid] > value) {
         high = mid - 1
       } else {
         if (mid === arr.length - 1 || arr[mid+1] > value) {
           return mid
         }
         low = mid + 1
       }
     }
     return -1
   }
   ```

### 跳表

1. 定义: 链表+多级索引的结构，称之为跳表。
2. 特点：支持快速的插入，删除，查找操作。
3. 应用场景：Redis中的有序集合。
4. 查找、删除、插入的时间复杂度： O(logn);
5. 空间复杂度： O(n);
6. 对比红黑树：
   - 查找，插入，删除的时间复杂度一样；
   - 按区间查找跳表效率高些；
   - 跳表实现较简单；
   - 红黑树有内置实现的，业务开发时直接使用；

   ```javascript
// 设计跳表 -- todo
var Skiplist = function() {
     };
   
   /** 
   
    * @param {number} target
    * @return {boolean}
      */
      Skiplist.prototype.search = function(target) {
   
   };
   
   /** 
   
    * @param {number} num
    * @return {void}
      */
      Skiplist.prototype.add = function(num) {
   
   };
   
   /** 
   
    * @param {number} num
    * @return {boolean}
      */
      Skiplist.prototype.erase = function(num) {
   
   };
   
   /**
   
    * Your Skiplist object will be instantiated and called as such:
    * var obj = new Skiplist()
    * var param_1 = obj.search(target)
    * obj.add(num)
    * var param_3 = obj.erase(num)
    */
   ```



### 散列表

1. 定义：数组支持按照下标随机访问数据的特性，所以散列表是数组的一种扩展；

2. 散列函数:
   - 散列函数计算得到的散列值是一个非负整数；
   - 如果key1 = key2, 那 hash(key1) = hash(key2);
   - 如果key1 != key2, 那 hash(key1) != hash(key2);
   
3. 散列冲突：开放寻址法、链表法

4. 应用场景：
   - word文档中单词拼写功能；
   - 10万条URL访问日志，如何按照访问次数给URL排序；
   
5. 如何设计一个工业级的散列表

   - 散列函数设计：随机且均匀分布，减少散列冲突；
   - 散列冲突解决方法选择：链表法更加普遍，链表可以换成红黑树等；小规模数据，适合开放寻址法；
   - 根据装载因子动态扩容；

6. JavaScript中Object,Map是基于哈希表实现；

7. 链表+散列表应用实例

   - LRU缓存淘汰算法；

     ```javascript
     // LRU缓存淘汰算法 -- todo
     ```

   - Redis有序集合；

   - Java 的 LinkedHashMap；

### 哈希算法

1. 定义： 哈希算法就是散列函数，英文都是`hash`；

2. 原理：将任意长度的二进制值串映射为固定长度的二进制值串；

3. 特点：

   - 不能从哈希值，反向推到出原始数据；
   - 原始数据只要改了一点，哈希值就不同；
   - 哈希值相同的概率非常小；
   - 哈希算法的执行效率要非常高；

4. 哈希算法的应用：

   - 安全加密：如MD5， SHA，如区块链使用SHA256；
   - 唯一标识；如图片名称；
   - 数据校验：BT下载，校验文件的完整性；
   - 散列函数；
   - 负载均衡：ip哈希；
   - 数据分片；
   - 分布式存储；一致性哈希算法；

5. 经典试题

   ```javascript
   /**
    * 获取最长不重复字符串, 哈希表+滑动窗口
    * 时间复杂度O(n)
    * @param {string} s
    * @return {number}
    */
   var lengthOfLongestSubstring = function (s) {
     const map = new Map()
     let max = 0
     let last = 0
     for (let i = 0, n = s.length; i < n; i++) {
       if (map.has(s[i])) {
         max = map.size > max ? map.size : max
         // 滑动窗口，移除重复前数据
         const value = map.get(s[i])
         for (let k = last; k <= value; k++) {
           map.delete(s[k])
         }
         last = value + 1
         // 设置当前值
         map.set(s[i], i)
       } else {
         map.set(s[i], i)
       }
     }
     max = map.size > max ? map.size : max
     return max
   }
   ```

   

### 二叉树

1. 定义

   - 二叉树：每个节点最多有两个节点，左节点，有节点；
   - 完全二叉树：叶子节点都在最后两层，最后一层叶子节点都靠左排列，除了最后一层，其它层叶子节点个数都是满的。
   - 满二叉树：叶子节点在最底层，除了叶子节点，所有节点都有两个子节点

2. 存储二叉树方法：

   - 链式存储法：；
   - 顺序存储法：适合完全二叉树，满二叉树；

3. 二叉树的遍历，时间复杂度O(n)

   - 前序遍历

     ```javascript
     // 前序遍历 -- 递归
     function preFn(node, result) {
       if (!node) return
       result.push(node.value)
       preFn(node.left, result)
       preFn(node.right, result)
     }
     var node = {
       left: {
         value: 1
       },
      value: 2,
      right: {
       value: 3,
       left: {
         value: 4
       }
      }
     }
     let result = []
     preFn(node, result)
     console.log('result', result)
     ```

     ```javascript
     // 前序遍历 -- 非递归
     function preFn(node, result) {
       if (!node) return
       let stack = []
       stack.push(node)
       while (stack.length) {
         // 取出最后一个
         let temp = stack.pop()
         result.push(temp.value)
         // 先放入右节点
         if (temp.right) {
        		stack.push(temp.right)
         }
    		// 再放入左节点  
         if (temp.left) {
        		stack.push(temp.left)
         }
       }
     }
     ```
   
     
   
   - 中序遍历
   
       ```javascript
         // 中序遍历 -- 递归
         function cenFn(node, result) {
           if (!node) return
           cenFn(node.left, result)
           result.push(node.value)
           cenFn(node.right, result)
        }
       ```
   
       ```javascript
       // 中序遍历 -- 非递归
          function cenFn(node, result) {
          if (!node) return
        let stack = []
          let temp = node
          while (temp || stack.length) {
            // 左节点入栈
            while (temp) {
              stack.push(temp)
              temp = temp.left
            }
            // 取出最后一个节点
            let last = stack.pop()
            result.push(last.value)
            // 右节点重复上述操作
            temp = last.right
          }
        }
       ```

   - 后序遍历
     ```javascript
     // 后序遍历 -- 递归
     function lastFn(node, result) {
       if (!node) return
       lastFn(node.left, result)
       lastFn(node.right, result)
       result.push(node.value)
     }
     
     
     ```
     
     ```javascript
     // 后序遍历 -- 非递归
     function lastFn(node, result) {
       let stack = []
       stack.push(node)
       while (stack.length) {
         // 取出最后一个
         let temp = stack.pop()
         // 队首插入法
         result.unshift(temp.value)
         // 放入左节点
         if (temp.left) {
           stack.push(temp.left)
         }
         // 放入右节点
         if (temp.right) {
           stack.push(temp.right)
         }
       }
     }
     ```
     
     

### 二叉查找树

1. 定义：在树中任意一个节点，左子树中的每个节点的值小于该节点，右子树中的每个节点的值大于该节点；

2. 特点：支持动态数据集合的快速查找、插入、删除操作；

3. 其它特性

   - 中序遍历，可以输出有序数列，时间复杂度O(n)；
   - 支持重复数据；相同数据可以存在同一个节点上；或者存在右子节点上；

4. 二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是 O(n) 和 O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。

5. 对比散列表

   - 散列表是无序的；
   - 散列表扩容耗时多；
   - 散列表需要考虑散列冲突问题，设计复杂；

6. 经典例子

   - 查找

     ```javascript
     // 二叉查找树--查找
     function find(bTree, value) {
       let node = bTree
       while (node) {
         if (node.value === value) {
           return node
         }
         else if (node.value < value) {
         	node = node.left
         } else {
           node = node.right
         }
       }
       return null
     }
     ```

     

   - 插入

     ```javascript
     // 二叉查找树 -- 插入
     function insert(bTree, value) {
     	let node = bTree
       if (!node) {
         node = {
           value
         }
         return node
       }
       while (!node) {
         if (value > node.value) {
           if (!node.right) {
             node.right = {
               value
             }
             return node
           } else {
             node = node.right
           }
         } else {
           if (!node.left) {
             node.left = {
               value
             }
             return node
           } else {
             node = node.left
           }
         }
       }
       return node
     }
     ```

     

   - 删除

     ```javascript
     // 二叉查找树 -- 删除
     // 待删除节点三种情况分析： 1. 没有子节点， 2. 只有一个子节点  3. 有两个子节点，找到右子树中最小节点
     function del(bTree, value) {
       let p = bTree // p为指向要删除的节点
       let pFather = null // pp为p的父节点
     	// 遍历找到要删除的节点
       while (p && p.value !== value) {
         pFather = p
         if (value > p.value) {
           p = p.right
         } else {
           p = p.left
         }
       }
       // 没有找到待删除的节点，返回false
       if (!p) return false
       
       // 要删除的节点有两个节点，查找右子树中最小节点替换
       if (p.left && p.right) {
         let minP = p.right
         let minPFather = p // 表示minP的父节点
         while (minP.left) {
           minPFather = minP
     			minP = minP.left
         }
         p.data = minP.data // 将minP的数据替换到p中
         p = minP; // 下面就变成了删除minP了 pp = minPP;
         pFather = minPFather;
       }
       
      // 删除节点是叶子节点或者仅有一个子节点
       let child = null; // p的子节点 
       if (p.left != null) child = p.left; 
       else if (p.right != null) child = p.right; 
       else child = null; 
       
       if (pFather == null) p = child; 
       // 删除的是根节点 
       else if (pFather.left === p) pFather.left = child; 
       else pFather.right = child;  
     }
     ```

   - 求二叉树高度

     ```javascript
     // 求出一棵给定二叉树的确切高度
     function getHeight(tree) {
       if (!node) return -1
       return Math.max(getHeight(tree.left), getHeight(tree.right)) + 1
     }
     ```
```
     
     

### 平衡二叉查找树、红黑树

1. 定义：

   - 平衡二叉查找树：二叉树中，任意节点左右子树的高度差不能大于1；
   - 红黑树：红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 `log2n`，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。

2. 为什么喜欢用红黑树？

   红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。
   
3. 经典例子：

   （1）判断是否是平衡二叉树

   ```javascript
   // 方法一，按照定义求解，自顶向下--递归 O(n)
   function isBalanceTree(tree) {
     if (!tree) return true
     let l = getHeight(tree.left)
     let r = getHeight(tree.right)
     if (Math.abs(l -r) < 2 && isBalanceTree(tree.left) && isBalanceTree(tree.right)) {
       return true
     } else {
       return false
     }
   }
   
   // 计算二叉树的高度 O(logn)
   function getHeight(tree) {
     if (!tree) return -1
     let l = getHeight(tree.left)
     let r = getHeight(tree.right)
     return Math.max(l, r) + 1
   }
```

   ```javascript
   // 方法二，自底向上--递归 O(n)
   function isBalanceTree(tree) {
     return getDepth(tree) !== -1
   }
   
   function getDepth(tree) {
     if (!tree) return 0
     let l = getDepth(tree.left)
     if (l === -1) return -1
     let r = getDepth(tree.right)
     if (r === -1 || Math.abs(l - r) > 1) {
       return -1
     }
     return Math.max(l, r) + 1
   }
   ```

### 递归树

1. 定义：

   把大问题分解为小问题，然后再将小问题分解为小小问题，这样一层一层地分解，直到问题的数据规模被分解得最够小为止。我们把这个一层一层的分解过程画成树，这棵树叫做递归树。

2. 作用：求解时间复杂度

3. 应用场景：

   - 快速排序的时间复杂度：O（nh） = O（nlogn）
   - 斐波那契数列的时间复杂度：fn = fn-1 + fn-2, 1+2+3+...+2^n-1=2^n-1; 即O(2^n)
   - 全排列的时间复杂度：`n+n*(n-1)+...+n!`, 即 O(n!)到O(n*n!)

### 堆和堆排序

1. 定义：堆是一个完全二叉树，堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

2. 分类：

   - 大顶堆：堆中每个节点的值大于等于其子树中每个节点的值；
   - 小顶堆：堆中每个节点的值小于等于其子树中每个节点的值；

3. 存储堆的结构

   - 数组存储
   - 数组下标1存储第一个节点；
   - 数组下标为i的节点，其左子节点下标为`2*i`, 右节点为`2*i+1`

4. 插入元素操作--堆化

   ```javascript
   // 插入元素操作
   function insert(nums = [], val) {
     // 初始化堆
     if (!nums.length) {
       nums.push(null)
     }
     // 加入尾部
     nums.push(val)
     let i = nums.length - 1
     // 从下往上堆化
     while (i > 1) {
       let j = (i >> 1)
       // 若大于，就交换
       if (nums[i] > nums[j]) {
         [nums[i], nums[j]] = [nums[j], nums[i]]
       }
       i = j
     }
   }
   ```

   

5. 删除堆顶元素

   ```javascript
   // 删除堆顶元素
   function remove(nums, val) {
     let n = nums.length
     if (!n) {
       return false
     }
     nums[1] = nums[n-1]
     nums.pop()
     n = nums.length
     let i = 1
     // 从上往下堆化
     while (true) {
       let max = i
       if (2*i < n && nums[2*i] > nums[max]) {
         max = 2*i
       }
       if (2*i+1 < n && nums[2*i+1] > nums[max]) {
       	max = 2*i+1
   		}
       // 结束条件，子节点都小于该节点
       if (i === max) break
       // 交换
       [nums[i], nums[max]] = [nums[max], nums[i]]
       i = max
     }
   }
   ```

   

6. 堆排序

   实现步骤，分成两大步骤，建堆和排序；

   ```javascript
   /**
    * 堆排序
    * @param {Array} arr 
    */
   function heapSort(arr) {
     // 数据需从1开始
     arr.unshift(0)
     // 建堆
     heapBuild(arr)
     console.log('headBuild after', arr)
     // 大顶堆排序
     sort(arr)
     console.log('sort after', arr)
     // 去除首个元素
     arr.shift()
   }
   
   /**
    * 建堆
    * @param {Array} arr 
    */
   function heapBuild(arr) {
     let n = arr.length
     if (n < 2) return
     // 从后往前堆化；其中i> n/2的都是叶子节点，无需堆化
     for (let i = n >> 1; i >= 1; i--) {
       heapify(arr, i, n - 1)
     }
   }
   
   /**
    * 从上往下堆化
    * @param {Array} arr 待堆化数组
    * @param {Number} i 开始位置
    * @param {Number} count 结束位置
    */
   function heapify(arr, i, count) {
     let n = count + 1
     while (true) {
       let max = i
       // 找到左右子节点中最大节点
       if (2*i < n && arr[2*i] > arr[max]) {
         max = 2*i
       }
       if (2*i + 1 < n && arr[2*i+1] > arr[max]) {
         max = 2*i + 1
       }
       // 终止条件，左右子节点都小于父节点
       if (i === max) {
         break
       }
       // 交换最大子节点与父节点
       [arr[i], arr[max]] = [arr[max], arr[i]]
       i = max
     }
   }
   
   /**
    * 大顶堆排序
    * @param {Array} arr 
    */
   function sort(arr) {
     let n = arr.length
     if (n < 2) return
     // 遍历数组，每次把最大元素放置堆后面
     let i = n - 1
     while (i > 1) {
       // 交换首位和最后一位
       [arr[1], arr[i]] = [arr[i], arr[1]]
       i--
       // 从上往下堆化
       heapify(arr, 1, i)
     }
   }
   ```

   

7. 为什么快速排序比堆排序性能好

   - 堆排序数据访问的方式不友好，访问数组下标不连续，对CPU缓存不友好；
   - 堆排序的数据交换次数较多；

8. 堆排序其它经典应用

   - 优先级队列；

     ​	（1）优先级队列，最高效的实现方式就是堆

     ​	（2）应用场景：

     - 合并有序小文件： 假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列，小顶堆实现。
     - 高性能定时器：不用每隔1秒就轮询一次，只需要维护一个小顶堆，按照任务设定的执行时间，放入该堆中。

   - 利用堆求Top K；

     我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。 时间复杂度O（nlogk）

     ```javascript
     /**
      * @param {number} k
      * @param {number[]} nums
      */
     var KthLargest = function(k, nums) {
       this.littleHeap = [null]
       this.k = k
       for (let item of nums) {
         this.add(item)
       }
     };
     
     /** 
      * @param {number} val
      * @return {number}
      */
     KthLargest.prototype.add = function(val) {
       // 首个直接新增
       if (this.littleHeap.length === 1) {
         this.littleHeap.push(val)
         return this.littleHeap[1]
       }
       if (this.littleHeap.length <= this.k) {
         this.littleHeap.push(val)
         heapify2(this.littleHeap)
       } else if (val > this.littleHeap[1]) {
         this.littleHeap[1] = val
         heapify(this.littleHeap)
       }
       return this.littleHeap[1]
     };
     
     
     /**
      * 自顶向下堆化
      * @param {numbers[]} arr 
      */
     function heapify(arr) {
       let n = arr.length
       let i = 1
       while (true) {
         let max = i
         if (2*i < n && arr[2*i] < arr[max]) {
           max = 2*i
         }
         if (2*i + 1 < n && arr[2*i+1] < arr[max]) {
           max = 2*i + 1
         }
         if (i === max) {
           break
         }
         // 交换
         [arr[i], arr[max]] = [arr[max], arr[i]]
         i = max
       }
     }
     
     /**
      * 自下向上堆化
      * @param {numbers[]} arr 
      */
     function heapify2(arr) {
       let i = arr.length - 1
       while (i > 1) {
         let j = (i >> 1)
         // 若大于，就交换
         if (nums[i] < nums[j]) {
           [nums[i], nums[j]] = [nums[j], nums[i]]
         }
         i = j
       }
     }
     ```

     

   - 利用堆求中位数；

     我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。时间复杂度O(logn)

### 图

1. 定义：一种复杂的非线性表结构；

2. 元素：顶点、边、度（顶点的边条数）；

3. 常见算法：图的搜索、最短路径、最小生成树、二分图；

4. 存储结构：

   - 邻接矩阵，即一个二维数组；
   - 邻接表，即链表；

5. 广度优先遍历

   ```javascript
   /**
    * BFS 广度优先搜索（树）-- 非递归
    */
   function BFS(tree) {
     let queue = []
     let result = []
     queue.push(tree)
     while (queue.length) {
       let temp = queue.shift()
       result.push(temp.value)
       if (temp && temp.children && temp.children.length) {
         queue.push(...temp.children)
       }
     }
     return result
   }
   
   /**
    * BFS 广度优先搜索（树） -- 递归
    */
   function BFS2(tree, result = []) {
     if (!tree) return
     // 顶点推入
     if (!result.length) {
       result.push(tree.value)
     }
     if (!tree.children) return
     for (let item of tree.children) {
       result.push(item.value)
     }
     for (let item of tree.children) {
       BFS2(item, result)
     }
   }
   ```

   

6. 深度优先遍历

   ```javascript
   /**
    * DFS 深度优先搜索(树)--非递归
    */
   function DFS(tree) {
     let stack = []
     let result = []
     stack.push(tree)
     while (stack.length) {
       let temp = stack.pop()
       result.push(temp.value)
       if (temp.children && temp.children.length) {
         let tempChildReverse = temp.children.reverse()
         stack.push(...tempChildReverse)
       }
     }
     return result
   }
   
   /**
    * DFS 深度优先搜索（树）--递归
    */
   function DFS2(tree, result = []) {
     if (!tree) return
     result.push(tree.value)
     if (!tree.children || !tree.children.length) return
     for (let item of tree.children) {
       DFS2(item, result)
     }
   }
   // 测试
   let tree = {
     value: 8,
     children: [
       { value: 7},
       { value: 6, children: [
         { value: 6.1},
         { value: 6.2}
       ]},
       { value: 5},
       { value: 4},
     ]
   }
   let result = []
   DFS2(tree, result)
   console.log('result', result)
   ```

### 字符串匹配

1. 定义：字符串匹配，主串n, 模式串m；
2. 应用场景： indexOf, include, find等内置函数；
3. 常见算法
   - BF算法： 暴力匹配算法，时间复杂度O(m, n)；
   - RK算法：BF算法升级版，哈希模式串后在比较， 时间复杂度O(n)；
   - BM算法：怀字符规则、好字符规则，常见文本编辑中使用；
   - KMP算法：好前缀规则， 时间复杂度O（n+m）;
   - Trie树：解决字符串快速匹配问题，如搜索引擎的提示；
   - AC自动机：多模式串匹配算法，为了快速在主串中查找多个模式串；

### 贪心算法

### 分治算法

### 回溯算法

### 动态规划

## 高级算法

### 拓扑排序

### 最短路径





## 动态规划

### 斐波那契数列

描述：1,1,2,3,5,8...

```javascript
// 递归 O(2^n)
function fb (n) {
  if (n < 3) {
	return 1
  }
  return fb(n-1) + fb(n-2)
}

// 递归优化（空间换时间）O(n)
function fb (n) {
  // 实际执行函数
  function f (amount) {
    if (amount < 3) {
      return 1
    }
    if (cache[amount]) {
      return cache[amount]
    }
    cache[amount] = f(amount-1) + f(amount-2)
    console.log('cache[amount]', cache[amount])
    return cache[amount]
  }
  // 缓存计算结果
  const cache = []
  return f(n)
}
```

```javascript
/**
 * 尾递归 O(n)
 * @param {Number} f1 第一项值
 * @param {Number} f2 第二项值
 * @param {Number} n 第n次
 */
function fb (f1, f2, n) {
  if (n === 1 ) {
      return f1
  }
  return fb(f2, f1+f2, n-1)
}
```

```javascript
// 遍历 o(n)
function fb (n) {
  if ( n < 3) {
    return 1
  }
  let s = 0
  let a = 1
  let b = 1
  for (let i = 2; i < n; i++) {
    s = a + b
    a = b
    b = s
  }

  return s
}
```

```javascript
// 动态规划 O(n) 
function fb (n) {
  const cache = [1, 2]
  for (let i = 2; i <= n; i++) {
    cache[i] = cache[i-1] + cache[i-2]
  }
  return cache[n]
}
```

```javascript
// 斐波那契通项公式
function fb(n) {
  return (((1+Math.sqrt(5))/2)^n - ((1-Math.sqrt(5))/2)^n)/Math.sqrt(5)
}
```



### 找零问题

描述：一个算法星球央行发布了奇葩币，币值分别为1,5,11，求最少多少个硬币凑成n元；

```javascript
// 递归 O(3^n)
function f (n) {
  let min = Infinity
  if (n < 0) {
    return min
  }
  if (n === 0) {
    return 0
  }
  min = Math.min(f(n-1) + 1, f(n-5) + 1, f(n-11) + 1)
  return min
}
```

``` javascript
// 递归优化 （空间换时间）O(n)
// 缺陷：依然会爆栈
function f(n) {
  function g(m) {
    let min = Infinity
    if (cache[m]) {
      return cache[m]
    }
    if (m < 0) {
      return min
    }
    if (m === 0) {
      return 0
    }
    // 注意函数名字易错
    min = Math.min(g(m-1) + 1, g(m-5) + 1, g(m-11) + 1)
    cache[m] = min
    return min
  }
  const cache = []
  return g(n)
}
```

```javascript
// 动态规划 O(n)
function f(n) {
  // 初始缓存为最大值   
  const cache = new Array(n+1).fill(Infinity)
  if (n < 0) {
    return Infinity
  }
  cache[0] = 0
  for (let i = 1; i <= n; i++) {
    // 推导公式：fn = Math.min(fn-1, fn-5, fn-11) + 1
    if (i - 5 < 0) {
	  cache[i] = cache[i-1] + 1
    } else if (i - 11 < 0) {
      cache[i] = Math.min(cache[i-1], cache[i-5]) + 1
    } else {
      cache[i] = Math.min(cache[i-1], cache[i-5], cache[i-11]) + 1
    }
  }
  return cache[n]
}
```

```javascript
// 描述：给出不同面额硬币coins和一个总金额n, 求凑成总金额n的最小硬币数；
// 动态规划 O(coins.length * n)
function f(coins, n) {
  // 初始缓存为最大值   
  const cache = new Array(n+1).fill(Infinity)
  if (n < 0) {
    return Infinity
  }
  cache[0] = 0
  for (let i = 1; i <= n; i++) {
    // 推断公式：fn = Math.min(f[n-ci]) + 1
    for (const coin of coins) {
      if (coin <= i) {
        cache[i] = Math.min(cache[i], cache[i-coin] + 1)
      }
     }
   }
   return cache[n] === Infinity ? -1 : cache[n]
}
```

### 国王与金矿

有一个国家发现了5座金矿，挖矿工人10个。每座金矿要么全挖，要么不挖。要想得到尽可能多的黄金，应该挖哪几座金矿？

金矿数组：500金/5人，400金/5人，350金/3人，300金/4人，200金/3人

```javascript
/**
 * 挖矿选择 -- 递归法
 * @param {Number} m 金矿数量
 * @param {Number} n 工人数量
 * @param {Array} g 所需工人（数）
 * @param {Array} h 金矿产量（金）
 * @returns {Number} 最多挖矿金额
 */
function f (m, n, g, h) {
  if (m <= 0 || n <= 0) {
		return 0
	}
  // 工人数不够
  if (n < g[m-1]) {
    return 0
 	}
  
  // 只有一座金矿
	if (m === 1) {
    return n >= g[0] ? h[0] : 0
	}
  // 挖与不挖
	let did = f(m-1, n-g[m-1], g, h) + h[m-1]
	let noDid = f(m-1, n, g, h)
  return Math.max(did, noDid)
}
```



## 正则

### 正则语法

1. 元字符

   - `^ `: 匹配字符串开始；
   - `$`:匹配字符串结束；
   - `.`:匹配除换行符之外所有字符；
   - `\s`: 匹配任意空白字符；
   - `\w`: 匹配字母，数字，下划线；
   - `|`：或匹配，如 a|b； 
   - `\b`: 匹配单词边界；
   - `\d`: 匹配数字，等同于[0-9]

2. 反义字符

   - `[^x]`: 匹配除字符x以外的所有字符；

3. 重复匹配

   - `*`： >=0 重复任意次数；
   - `?`: 0次或者1次；
   - +： >=1 次数；
   - {n}: 重复出现n次；

4. 分组

   - `(exp)`: 小圆括号进行分组

5. 修饰符

   - `i`： ignoreCase, 忽略字母的大小写；

   - `g`: global， 进行全局匹配；

   - `m`： multi line, 多行匹配；

     

### 正则经典例子

1. js实现trim，去除首尾空白字符

   ```javascript
   function myTrim () {
     let str = this
     let reg = /(^\s*)|(\s*$)/g
     str = str.replace(reg, '')
     return str
   }
   String.prototype.myTrim = myTrim
   ```

2. js判断一个字符串是否是正确的符号嵌套匹配，如[],{},()

   ```javascript
   function isRight()
   ```

   

3. xx

4. xx

